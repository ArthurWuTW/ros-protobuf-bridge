#!/usr/bin/env python

import sys
import ntpath
import os
import re
import hashlib

try:
    from cStringIO import StringIO  # Python 2.x
except ImportError:
    from io import StringIO  # Python 3.x

def ThrowCompilationError(error_string):
    """
    :param error_string:
    :return:
    """
    sys.exit("{0}:1:error Protobuf_ROSmsgGen: {1}\n".format(sys.argv[1], error_string))

def Out(s, str):
    s.write("%s\n"%str)

def WriteChecksumTrait(s, pkg_name, class_name):
    checksum = hashlib.md5("%s::%s" %(pkg_name, class_name)).hexdigest()
    str = """
    template <>
    struct MD5Sum<@Package@::@Class@> {
    static const char* value(@Package@::@Class@ const& o) {
      return "@Checksum@";
    }
    static const char* value() {
      return "@Checksum@";
    }
    };
    """
    str = str.replace("@Checksum@", checksum)
    str = str.replace("@Class@", class_name)
    str = str.replace("@Package@", pkg_name)
    s.write(str)

def WriteDataTypeTrait(s, pkg_name, class_name):
    str = """
    template <>
    struct DataType<@Package@::@Class@> {
    static const char* value(@Package@::@Class@ const& o) {
      return "@Package@/@Class@";
    }
    static const char* value() {
      return "@Package@/@Class@";
    }
    };
    """
    str = str.replace("@Class@", class_name)
    str = str.replace("@Package@", pkg_name)
    s.write(str)

def WriteDefinitionTrait(s, pkg_name, class_name):
    str = """
    template <>
    struct Definition<@Package@::@Class@> {
    static const char* value(@Package@::@Class@ const& o) {
      return "Protobuf generates msg for @Package@::@Class@";
    }
    static const char* value() {
      return "Protobuf generates msg for @Package@::@Class@";
    }
    };
    """
    str = str.replace("@Class@", class_name)
    str = str.replace("@Package@", pkg_name)
    s.write(str)

def WriteSerializationTrait(s, pkg_name, class_name):
    str = """
    namespace serialization {
    template <>
    struct Serializer<@Package@::@Class@> {
    template <typename Stream>
    inline static void write(Stream& stream, @Package@::@Class@ const& o) {
      std::string ser_bytes;
      if (!o.SerializeToString(&ser_bytes)) {
        std::cerr << "Serialization failed." << std::endl;
        return;
      }
      memcpy(stream.advance(ser_bytes.size()), ser_bytes.c_str(), ser_bytes.size());
    }

    template <typename Stream>
    inline static void read(Stream &stream, @Package@::@Class@ &o) {
      std::string deser_bytes;
      deser_bytes.resize(stream.getLength());
      memcpy(&deser_bytes[0], stream.advance(stream.getLength()),
             stream.getLength());
      if (!o.ParseFromString(deser_bytes)) {
        std::cerr << "Deserialization failed." << std::endl;
        return;
      }
    }

    inline static uint32_t
    serializedLength(@Package@::@Class@ const &o) {
      return o.ByteSizeLong();
    }
    };
    }  // namespace serialization
    """
    str = str.replace("@Class@", class_name)
    str = str.replace("@Package@", pkg_name)
    s.write(str)

def WriteClassTraits(s, pkg_name, class_name):
    Out(s,"namespace message_traits {\n")
    WriteChecksumTrait(s, pkg_name, class_name)
    WriteDataTypeTrait(s, pkg_name, class_name)
    WriteDefinitionTrait(s, pkg_name, class_name)
    Out(s,"}  // namespace message_traits")
    WriteSerializationTrait(s, pkg_name, class_name)

def GenerateCppHeader(proto_file_full):
    """
    Umbrella function that generates the entire header implementing ROS msg traits
    :param proto_file_full
    :return:
    """
    s = StringIO()

    file_w_extension = ntpath.basename(proto_file_full)
    file_name = ntpath.splitext(file_w_extension)[0]

    file = open(proto_file_full, "r")
    proto_des = file.read()
    entries = re.split("[\r\n;]+", proto_des)
    res = ("package" in e for e in entries)
    pkg_x = [x.split()[1] for x in entries if "package" in x]
    # make sure that package name exists
    if (len(pkg_x) != 1):
        ThrowCompilationError("Must specify a package name")
    pkg_name = pkg_x[0]
    # make sure its not a nested package name ... Not supported for now
    if [dot for dot in pkg_name if "." in dot]:
        ThrowCompilationError("Nested package names not supported")

    # now get all the class names
    class_names = [x.split()[1] for x in entries if "message" in x]

    #print entries
    # write includes
    Out(s,"/// @author    Auto-generated by {:s}".format(sys.argv[0]))
    Out(s,"///")
    Out(s,"/// @warning  This file has been autogenerated by the build process.")
    Out(s,"///           Do not modify this file.\n")

    # include guard
    Out(s,"#pragma once\n")

    Out(s,"#include <{:s}.pb.h>".format(file_name))
    Out(s,"#include <ros/message_traits.h>")
    Out(s,"#include <ros/serialization.h>\n")

    Out(s,"namespace ros {")
    for c in class_names:
        WriteClassTraits(s, pkg_name, c)
    Out(s,"}  // namespace ros")
    # write code-gen only if different from build artifact
    header_file_name = '%s.ros.h' % file_name
    is_diff = True
    if os.path.isfile(header_file_name):
        with open(header_file_name, 'r') as f:
            is_diff = f.read() != s.getvalue()
    if is_diff:
        with open(header_file_name, 'w') as f:
            f.write(s.getvalue())
    s.close()

################################################
# Main routine
################################################
if __name__ == '__main__':

    # get the filename from arguments
    if (len(sys.argv) == 1):
        print("[Protobuf_ROSmsgGen] Usage: ./Protobuf_ROSmsgGen.py <file_name>.proto")
    else:
        # create a cpp header
        GenerateCppHeader(sys.argv[1])
